# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

interface ErrorInterface {
    "Generic error message"
    message: String
}

type CreateManyProfilePayload {
    "Number of created documents"
    createdCount: Int!
    "Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response."
    error: ErrorInterface
    "Documents IDs"
    recordIds: [MongoID!]!
    "Created documents"
    records: [Profile!]
}

type CreateManyUserPayload {
    "Number of created documents"
    createdCount: Int!
    "Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response."
    error: ErrorInterface
    "Documents IDs"
    recordIds: [MongoID!]!
    "Created documents"
    records: [User!]
}

type CreateOneProfilePayload {
    "Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response."
    error: ErrorInterface
    "Created document"
    record: Profile
    "Document ID"
    recordId: MongoID
}

type CreateOneUserPayload {
    "Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response."
    error: ErrorInterface
    "Created document"
    record: User
    "Document ID"
    recordId: MongoID
}

type Mutation {
    "Creates Many documents with mongoose defaults, setters, hooks and validation"
    profileCreateMany(records: [CreateManyProfileInput!]!): CreateManyProfilePayload
    "Create one document with mongoose defaults, setters, hooks and validation"
    profileCreateOne(record: CreateOneProfileInput!): CreateOneProfilePayload
    "Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document."
    profileRemoveById(_id: MongoID!): RemoveByIdProfilePayload
    "Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. "
    profileRemoveMany(
        "Filter by fields"
        filter: FilterRemoveManyProfileInput!,
        limit: Int = 100
    ): RemoveManyProfilePayload
    "Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document."
    profileRemoveOne(
        "Filter by fields"
        filter: FilterRemoveOneProfileInput,
        sort: SortRemoveOneProfileInput
    ): RemoveOneProfilePayload
    "Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it."
    profileUpdateById(_id: MongoID!, record: UpdateByIdProfileInput!): UpdateByIdProfilePayload
    "Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. "
    profileUpdateMany(
        "Filter by fields"
        filter: FilterUpdateManyProfileInput,
        limit: Int = 100,
        record: UpdateManyProfileInput!,
        skip: Int,
        sort: SortUpdateManyProfileInput
    ): UpdateManyProfilePayload
    "Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it."
    profileUpdateOne(
        "Filter by fields"
        filter: FilterUpdateOneProfileInput,
        record: UpdateOneProfileInput!,
        skip: Int,
        sort: SortUpdateOneProfileInput
    ): UpdateOneProfilePayload
    "Creates Many documents with mongoose defaults, setters, hooks and validation"
    userCreateMany(records: [CreateManyUserInput!]!): CreateManyUserPayload
    "Create one document with mongoose defaults, setters, hooks and validation"
    userCreateOne(record: CreateOneUserInput!): CreateOneUserPayload
    "Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document."
    userRemoveById(_id: MongoID!): RemoveByIdUserPayload
    "Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. "
    userRemoveMany(
        "Filter by fields"
        filter: FilterRemoveManyUserInput!,
        limit: Int = 100
    ): RemoveManyUserPayload
    "Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document."
    userRemoveOne(
        "Filter by fields"
        filter: FilterRemoveOneUserInput,
        sort: SortRemoveOneUserInput
    ): RemoveOneUserPayload
    "Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it."
    userUpdateById(_id: MongoID!, record: UpdateByIdUserInput!): UpdateByIdUserPayload
    "Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. "
    userUpdateMany(
        "Filter by fields"
        filter: FilterUpdateManyUserInput,
        limit: Int = 100,
        record: UpdateManyUserInput!,
        skip: Int,
        sort: SortUpdateManyUserInput
    ): UpdateManyUserPayload
    "Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it."
    userUpdateOne(
        "Filter by fields"
        filter: FilterUpdateOneUserInput,
        record: UpdateOneUserInput!,
        skip: Int,
        sort: SortUpdateOneUserInput
    ): UpdateOneUserPayload
}

"Information about pagination in a connection."
type PageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: String
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!
    "When paginating backwards, the cursor to continue."
    startCursor: String
}

type PaginationInfo {
    currentPage: Int!
    hasNextPage: Boolean
    hasPreviousPage: Boolean
    itemCount: Int
    pageCount: Int
    perPage: Int!
}

type Profile {
    _id: MongoID!
    createdAt: Date
    favourite_color: String
    some_date: Date
    some_number: Float
    updatedAt: Date
    user: MongoID
}

"A connection to a list of items."
type ProfileConnection {
    "Total object count."
    count: Int!
    "Information to aid in pagination."
    edges: [ProfileEdge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type ProfileEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: Profile!
}

"List of items with pagination."
type ProfilePagination {
    "Total object count."
    count: Int
    "Array of objects."
    items: [Profile!]
    "Information to aid in pagination."
    pageInfo: PaginationInfo!
}

type Query {
    profileById(_id: MongoID!): Profile
    profileByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsProfileInput): [Profile!]!
    profileConnection(
        "Forward pagination argument for returning at most first edges"
        after: String,
        "Backward pagination argument for returning at most last edges"
        before: String,
        "Filter by fields"
        filter: FilterFindManyProfileInput,
        "Forward pagination argument for returning at most first edges"
        first: Int,
        "Backward pagination argument for returning at most last edges"
        last: Int,
        "Sort argument for data ordering"
        sort: SortConnectionProfileEnum = _ID_DESC
    ): ProfileConnection
    profileCount(
        "Filter by fields"
        filter: FilterCountProfileInput
    ): Int
    profileMany(
        "Filter by fields"
        filter: FilterFindManyProfileInput,
        limit: Int = 100,
        skip: Int,
        sort: SortFindManyProfileInput
    ): [Profile!]!
    profileOne(
        "Filter by fields"
        filter: FilterFindOneProfileInput,
        skip: Int,
        sort: SortFindOneProfileInput
    ): Profile
    profilePagination(
        "Filter by fields"
        filter: FilterFindManyProfileInput,
        "Page number for displaying"
        page: Int,
        perPage: Int = 20,
        sort: SortFindManyProfileInput
    ): ProfilePagination
    userById(_id: MongoID!): User
    userByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsUserInput): [User!]!
    userConnection(
        "Forward pagination argument for returning at most first edges"
        after: String,
        "Backward pagination argument for returning at most last edges"
        before: String,
        "Filter by fields"
        filter: FilterFindManyUserInput,
        "Forward pagination argument for returning at most first edges"
        first: Int,
        "Backward pagination argument for returning at most last edges"
        last: Int,
        "Sort argument for data ordering"
        sort: SortConnectionUserEnum = _ID_DESC
    ): UserConnection
    userCount(
        "Filter by fields"
        filter: FilterCountUserInput
    ): Int
    userMany(
        "Filter by fields"
        filter: FilterFindManyUserInput,
        limit: Int = 100,
        skip: Int,
        sort: SortFindManyUserInput
    ): [User!]!
    userOne(
        "Filter by fields"
        filter: FilterFindOneUserInput,
        skip: Int,
        sort: SortFindOneUserInput
    ): User
    userPagination(
        "Filter by fields"
        filter: FilterFindManyUserInput,
        "Page number for displaying"
        page: Int,
        perPage: Int = 20,
        sort: SortFindManyUserInput
    ): UserPagination
}

type RemoveByIdProfilePayload {
    "Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response."
    error: ErrorInterface
    "Removed document"
    record: Profile
    "Document ID"
    recordId: MongoID
}

type RemoveByIdUserPayload {
    "Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response."
    error: ErrorInterface
    "Removed document"
    record: User
    "Document ID"
    recordId: MongoID
}

type RemoveManyProfilePayload {
    "Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response."
    error: ErrorInterface
    "Affected documents number"
    numAffected: Int
}

type RemoveManyUserPayload {
    "Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response."
    error: ErrorInterface
    "Affected documents number"
    numAffected: Int
}

type RemoveOneProfilePayload {
    "Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response."
    error: ErrorInterface
    "Removed document"
    record: Profile
    "Document ID"
    recordId: MongoID
}

type RemoveOneUserPayload {
    "Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response."
    error: ErrorInterface
    "Removed document"
    record: User
    "Document ID"
    recordId: MongoID
}

type UpdateByIdProfilePayload {
    "Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response."
    error: ErrorInterface
    "Updated document"
    record: Profile
    "Document ID"
    recordId: MongoID
}

type UpdateByIdUserPayload {
    "Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response."
    error: ErrorInterface
    "Updated document"
    record: User
    "Document ID"
    recordId: MongoID
}

type UpdateManyProfilePayload {
    "Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response."
    error: ErrorInterface
    "Affected documents number"
    numAffected: Int
}

type UpdateManyUserPayload {
    "Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response."
    error: ErrorInterface
    "Affected documents number"
    numAffected: Int
}

type UpdateOneProfilePayload {
    "Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response."
    error: ErrorInterface
    "Updated document"
    record: Profile
    "Document ID"
    recordId: MongoID
}

type UpdateOneUserPayload {
    "Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response."
    error: ErrorInterface
    "Updated document"
    record: User
    "Document ID"
    recordId: MongoID
}

type User {
    _id: MongoID!
    createdAt: Date
    email: String
    name: String!
    updatedAt: Date
}

"A connection to a list of items."
type UserConnection {
    "Total object count."
    count: Int!
    "Information to aid in pagination."
    edges: [UserEdge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type UserEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: User!
}

"List of items with pagination."
type UserPagination {
    "Total object count."
    count: Int
    "Array of objects."
    items: [User!]
    "Information to aid in pagination."
    pageInfo: PaginationInfo!
}

enum SortConnectionProfileEnum {
    _ID_ASC
    _ID_DESC
}

enum SortConnectionUserEnum {
    NAME_ASC
    NAME_DESC
    _ID_ASC
    _ID_DESC
}

enum SortFindByIdsProfileInput {
    _ID_ASC
    _ID_DESC
}

enum SortFindByIdsUserInput {
    NAME_ASC
    NAME_DESC
    _ID_ASC
    _ID_DESC
}

enum SortFindManyProfileInput {
    _ID_ASC
    _ID_DESC
}

enum SortFindManyUserInput {
    NAME_ASC
    NAME_DESC
    _ID_ASC
    _ID_DESC
}

enum SortFindOneProfileInput {
    _ID_ASC
    _ID_DESC
}

enum SortFindOneUserInput {
    NAME_ASC
    NAME_DESC
    _ID_ASC
    _ID_DESC
}

enum SortRemoveOneProfileInput {
    _ID_ASC
    _ID_DESC
}

enum SortRemoveOneUserInput {
    NAME_ASC
    NAME_DESC
    _ID_ASC
    _ID_DESC
}

enum SortUpdateManyProfileInput {
    _ID_ASC
    _ID_DESC
}

enum SortUpdateManyUserInput {
    NAME_ASC
    NAME_DESC
    _ID_ASC
    _ID_DESC
}

enum SortUpdateOneProfileInput {
    _ID_ASC
    _ID_DESC
}

enum SortUpdateOneUserInput {
    NAME_ASC
    NAME_DESC
    _ID_ASC
    _ID_DESC
}

input CreateManyProfileInput {
    createdAt: Date
    favourite_color: String
    some_date: Date
    some_number: Float
    updatedAt: Date
    user: MongoID
}

input CreateManyUserInput {
    createdAt: Date
    email: String
    name: String!
    updatedAt: Date
}

input CreateOneProfileInput {
    createdAt: Date
    favourite_color: String
    some_date: Date
    some_number: Float
    updatedAt: Date
    user: MongoID
}

input CreateOneUserInput {
    createdAt: Date
    email: String
    name: String!
    updatedAt: Date
}

input FilterCountProfileInput {
    AND: [FilterCountProfileInput!]
    OR: [FilterCountProfileInput!]
    _id: MongoID
    "List of *indexed* fields that can be filtered via operators."
    _operators: FilterCountProfileOperatorsInput
    createdAt: Date
    favourite_color: String
    some_date: Date
    some_number: Float
    updatedAt: Date
    user: MongoID
}

"For performance reason this type contains only *indexed* fields."
input FilterCountProfileOperatorsInput {
    _id: FilterCountProfile_idOperatorsInput
}

input FilterCountProfile_idOperatorsInput {
    exists: Boolean
    gt: MongoID
    gte: MongoID
    in: [MongoID]
    lt: MongoID
    lte: MongoID
    ne: MongoID
    nin: [MongoID]
}

input FilterCountUserInput {
    AND: [FilterCountUserInput!]
    OR: [FilterCountUserInput!]
    _id: MongoID
    "List of *indexed* fields that can be filtered via operators."
    _operators: FilterCountUserOperatorsInput
    createdAt: Date
    email: String
    name: String
    updatedAt: Date
}

input FilterCountUserNameOperatorsInput {
    exists: Boolean
    gt: String
    gte: String
    in: [String]
    lt: String
    lte: String
    ne: String
    nin: [String]
    regex: RegExpAsString
}

"For performance reason this type contains only *indexed* fields."
input FilterCountUserOperatorsInput {
    _id: FilterCountUser_idOperatorsInput
    name: FilterCountUserNameOperatorsInput
}

input FilterCountUser_idOperatorsInput {
    exists: Boolean
    gt: MongoID
    gte: MongoID
    in: [MongoID]
    lt: MongoID
    lte: MongoID
    ne: MongoID
    nin: [MongoID]
}

input FilterFindManyProfileInput {
    AND: [FilterFindManyProfileInput!]
    OR: [FilterFindManyProfileInput!]
    _id: MongoID
    "List of *indexed* fields that can be filtered via operators."
    _operators: FilterFindManyProfileOperatorsInput
    createdAt: Date
    favourite_color: String
    some_date: Date
    some_number: Float
    updatedAt: Date
    user: MongoID
}

"For performance reason this type contains only *indexed* fields."
input FilterFindManyProfileOperatorsInput {
    _id: FilterFindManyProfile_idOperatorsInput
}

input FilterFindManyProfile_idOperatorsInput {
    exists: Boolean
    gt: MongoID
    gte: MongoID
    in: [MongoID]
    lt: MongoID
    lte: MongoID
    ne: MongoID
    nin: [MongoID]
}

input FilterFindManyUserInput {
    AND: [FilterFindManyUserInput!]
    OR: [FilterFindManyUserInput!]
    _id: MongoID
    "List of *indexed* fields that can be filtered via operators."
    _operators: FilterFindManyUserOperatorsInput
    createdAt: Date
    email: String
    name: String
    updatedAt: Date
}

input FilterFindManyUserNameOperatorsInput {
    exists: Boolean
    gt: String
    gte: String
    in: [String]
    lt: String
    lte: String
    ne: String
    nin: [String]
    regex: RegExpAsString
}

"For performance reason this type contains only *indexed* fields."
input FilterFindManyUserOperatorsInput {
    _id: FilterFindManyUser_idOperatorsInput
    name: FilterFindManyUserNameOperatorsInput
}

input FilterFindManyUser_idOperatorsInput {
    exists: Boolean
    gt: MongoID
    gte: MongoID
    in: [MongoID]
    lt: MongoID
    lte: MongoID
    ne: MongoID
    nin: [MongoID]
}

input FilterFindOneProfileInput {
    AND: [FilterFindOneProfileInput!]
    OR: [FilterFindOneProfileInput!]
    _id: MongoID
    "List of *indexed* fields that can be filtered via operators."
    _operators: FilterFindOneProfileOperatorsInput
    createdAt: Date
    favourite_color: String
    some_date: Date
    some_number: Float
    updatedAt: Date
    user: MongoID
}

"For performance reason this type contains only *indexed* fields."
input FilterFindOneProfileOperatorsInput {
    _id: FilterFindOneProfile_idOperatorsInput
}

input FilterFindOneProfile_idOperatorsInput {
    exists: Boolean
    gt: MongoID
    gte: MongoID
    in: [MongoID]
    lt: MongoID
    lte: MongoID
    ne: MongoID
    nin: [MongoID]
}

input FilterFindOneUserInput {
    AND: [FilterFindOneUserInput!]
    OR: [FilterFindOneUserInput!]
    _id: MongoID
    "List of *indexed* fields that can be filtered via operators."
    _operators: FilterFindOneUserOperatorsInput
    createdAt: Date
    email: String
    name: String
    updatedAt: Date
}

input FilterFindOneUserNameOperatorsInput {
    exists: Boolean
    gt: String
    gte: String
    in: [String]
    lt: String
    lte: String
    ne: String
    nin: [String]
    regex: RegExpAsString
}

"For performance reason this type contains only *indexed* fields."
input FilterFindOneUserOperatorsInput {
    _id: FilterFindOneUser_idOperatorsInput
    name: FilterFindOneUserNameOperatorsInput
}

input FilterFindOneUser_idOperatorsInput {
    exists: Boolean
    gt: MongoID
    gte: MongoID
    in: [MongoID]
    lt: MongoID
    lte: MongoID
    ne: MongoID
    nin: [MongoID]
}

input FilterRemoveManyProfileInput {
    AND: [FilterRemoveManyProfileInput!]
    OR: [FilterRemoveManyProfileInput!]
    _id: MongoID
    "List of *indexed* fields that can be filtered via operators."
    _operators: FilterRemoveManyProfileOperatorsInput
    createdAt: Date
    favourite_color: String
    some_date: Date
    some_number: Float
    updatedAt: Date
    user: MongoID
}

"For performance reason this type contains only *indexed* fields."
input FilterRemoveManyProfileOperatorsInput {
    _id: FilterRemoveManyProfile_idOperatorsInput
}

input FilterRemoveManyProfile_idOperatorsInput {
    exists: Boolean
    gt: MongoID
    gte: MongoID
    in: [MongoID]
    lt: MongoID
    lte: MongoID
    ne: MongoID
    nin: [MongoID]
}

input FilterRemoveManyUserInput {
    AND: [FilterRemoveManyUserInput!]
    OR: [FilterRemoveManyUserInput!]
    _id: MongoID
    "List of *indexed* fields that can be filtered via operators."
    _operators: FilterRemoveManyUserOperatorsInput
    createdAt: Date
    email: String
    name: String
    updatedAt: Date
}

input FilterRemoveManyUserNameOperatorsInput {
    exists: Boolean
    gt: String
    gte: String
    in: [String]
    lt: String
    lte: String
    ne: String
    nin: [String]
    regex: RegExpAsString
}

"For performance reason this type contains only *indexed* fields."
input FilterRemoveManyUserOperatorsInput {
    _id: FilterRemoveManyUser_idOperatorsInput
    name: FilterRemoveManyUserNameOperatorsInput
}

input FilterRemoveManyUser_idOperatorsInput {
    exists: Boolean
    gt: MongoID
    gte: MongoID
    in: [MongoID]
    lt: MongoID
    lte: MongoID
    ne: MongoID
    nin: [MongoID]
}

input FilterRemoveOneProfileInput {
    AND: [FilterRemoveOneProfileInput!]
    OR: [FilterRemoveOneProfileInput!]
    _id: MongoID
    "List of *indexed* fields that can be filtered via operators."
    _operators: FilterRemoveOneProfileOperatorsInput
    createdAt: Date
    favourite_color: String
    some_date: Date
    some_number: Float
    updatedAt: Date
    user: MongoID
}

"For performance reason this type contains only *indexed* fields."
input FilterRemoveOneProfileOperatorsInput {
    _id: FilterRemoveOneProfile_idOperatorsInput
}

input FilterRemoveOneProfile_idOperatorsInput {
    exists: Boolean
    gt: MongoID
    gte: MongoID
    in: [MongoID]
    lt: MongoID
    lte: MongoID
    ne: MongoID
    nin: [MongoID]
}

input FilterRemoveOneUserInput {
    AND: [FilterRemoveOneUserInput!]
    OR: [FilterRemoveOneUserInput!]
    _id: MongoID
    "List of *indexed* fields that can be filtered via operators."
    _operators: FilterRemoveOneUserOperatorsInput
    createdAt: Date
    email: String
    name: String
    updatedAt: Date
}

input FilterRemoveOneUserNameOperatorsInput {
    exists: Boolean
    gt: String
    gte: String
    in: [String]
    lt: String
    lte: String
    ne: String
    nin: [String]
    regex: RegExpAsString
}

"For performance reason this type contains only *indexed* fields."
input FilterRemoveOneUserOperatorsInput {
    _id: FilterRemoveOneUser_idOperatorsInput
    name: FilterRemoveOneUserNameOperatorsInput
}

input FilterRemoveOneUser_idOperatorsInput {
    exists: Boolean
    gt: MongoID
    gte: MongoID
    in: [MongoID]
    lt: MongoID
    lte: MongoID
    ne: MongoID
    nin: [MongoID]
}

input FilterUpdateManyProfileInput {
    AND: [FilterUpdateManyProfileInput!]
    OR: [FilterUpdateManyProfileInput!]
    _id: MongoID
    "List of *indexed* fields that can be filtered via operators."
    _operators: FilterUpdateManyProfileOperatorsInput
    createdAt: Date
    favourite_color: String
    some_date: Date
    some_number: Float
    updatedAt: Date
    user: MongoID
}

"For performance reason this type contains only *indexed* fields."
input FilterUpdateManyProfileOperatorsInput {
    _id: FilterUpdateManyProfile_idOperatorsInput
}

input FilterUpdateManyProfile_idOperatorsInput {
    exists: Boolean
    gt: MongoID
    gte: MongoID
    in: [MongoID]
    lt: MongoID
    lte: MongoID
    ne: MongoID
    nin: [MongoID]
}

input FilterUpdateManyUserInput {
    AND: [FilterUpdateManyUserInput!]
    OR: [FilterUpdateManyUserInput!]
    _id: MongoID
    "List of *indexed* fields that can be filtered via operators."
    _operators: FilterUpdateManyUserOperatorsInput
    createdAt: Date
    email: String
    name: String
    updatedAt: Date
}

input FilterUpdateManyUserNameOperatorsInput {
    exists: Boolean
    gt: String
    gte: String
    in: [String]
    lt: String
    lte: String
    ne: String
    nin: [String]
    regex: RegExpAsString
}

"For performance reason this type contains only *indexed* fields."
input FilterUpdateManyUserOperatorsInput {
    _id: FilterUpdateManyUser_idOperatorsInput
    name: FilterUpdateManyUserNameOperatorsInput
}

input FilterUpdateManyUser_idOperatorsInput {
    exists: Boolean
    gt: MongoID
    gte: MongoID
    in: [MongoID]
    lt: MongoID
    lte: MongoID
    ne: MongoID
    nin: [MongoID]
}

input FilterUpdateOneProfileInput {
    AND: [FilterUpdateOneProfileInput!]
    OR: [FilterUpdateOneProfileInput!]
    _id: MongoID
    "List of *indexed* fields that can be filtered via operators."
    _operators: FilterUpdateOneProfileOperatorsInput
    createdAt: Date
    favourite_color: String
    some_date: Date
    some_number: Float
    updatedAt: Date
    user: MongoID
}

"For performance reason this type contains only *indexed* fields."
input FilterUpdateOneProfileOperatorsInput {
    _id: FilterUpdateOneProfile_idOperatorsInput
}

input FilterUpdateOneProfile_idOperatorsInput {
    exists: Boolean
    gt: MongoID
    gte: MongoID
    in: [MongoID]
    lt: MongoID
    lte: MongoID
    ne: MongoID
    nin: [MongoID]
}

input FilterUpdateOneUserInput {
    AND: [FilterUpdateOneUserInput!]
    OR: [FilterUpdateOneUserInput!]
    _id: MongoID
    "List of *indexed* fields that can be filtered via operators."
    _operators: FilterUpdateOneUserOperatorsInput
    createdAt: Date
    email: String
    name: String
    updatedAt: Date
}

input FilterUpdateOneUserNameOperatorsInput {
    exists: Boolean
    gt: String
    gte: String
    in: [String]
    lt: String
    lte: String
    ne: String
    nin: [String]
    regex: RegExpAsString
}

"For performance reason this type contains only *indexed* fields."
input FilterUpdateOneUserOperatorsInput {
    _id: FilterUpdateOneUser_idOperatorsInput
    name: FilterUpdateOneUserNameOperatorsInput
}

input FilterUpdateOneUser_idOperatorsInput {
    exists: Boolean
    gt: MongoID
    gte: MongoID
    in: [MongoID]
    lt: MongoID
    lte: MongoID
    ne: MongoID
    nin: [MongoID]
}

input UpdateByIdProfileInput {
    createdAt: Date
    favourite_color: String
    some_date: Date
    some_number: Float
    updatedAt: Date
    user: MongoID
}

input UpdateByIdUserInput {
    createdAt: Date
    email: String
    name: String
    updatedAt: Date
}

input UpdateManyProfileInput {
    createdAt: Date
    favourite_color: String
    some_date: Date
    some_number: Float
    updatedAt: Date
    user: MongoID
}

input UpdateManyUserInput {
    createdAt: Date
    email: String
    name: String
    updatedAt: Date
}

input UpdateOneProfileInput {
    createdAt: Date
    favourite_color: String
    some_date: Date
    some_number: Float
    updatedAt: Date
    user: MongoID
}

input UpdateOneUserInput {
    createdAt: Date
    email: String
    name: String
    updatedAt: Date
}


"The `ID` scalar type represents a unique MongoDB identifier in collection. MongoDB by default use 12-byte ObjectId value (https://docs.mongodb.com/manual/reference/bson-types/#objectid). But MongoDB also may accepts string or integer as correct values for _id field."
scalar MongoID

scalar Date

"The string representation of JavaScript regexp. You may provide it with flags \"/^abc.*/i\" or without flags like \"^abc.*\". More info about RegExp characters and flags: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions"
scalar RegExpAsString